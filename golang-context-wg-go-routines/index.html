<!doctype html>
<html>
<head>
    <meta charset='utf-8'>
    <title>Using Go&#39;s Context and WaitGroups to gracefully handle goroutines</title>
    <link href="https://fonts.googleapis.com/css?family=Merriweather&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://andybrewer.github.io/mvp/mvp.css">
    <link rel="stylesheet" href="/static/base.css">
    <link rel="stylesheet" href="/static/pygments.css">

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

</head>
<body>
    <header>
    
<h1>
    <span><a href='/'>&laquo;</a></span>
    Using Go&#39;s Context and WaitGroups to gracefully handle goroutines 
</h1>
<p class='published-date'>Last updated Feb 15 2021</p>

    </header>
    <main>
    
<article>
    <p>Recently I was building a application that would tick on an interval and on each tick,
produce potentially thousands of goroutines. I wanted to ensure when the application was terminated, it would exit gracefully and quickly, even if particular goroutines were processing slowly.</p>
<p>Initially, I was using <code>sync.WaitGroup</code> to control flow, primarily around how I log
output, but I quickly realized that if I created many goroutines and even a small
collection of them did not return immediately, my application would hang when being
terminated. This led me to reviewing <code>context.WithCancel</code> and understanding how I can
adjust my application to be well suited for quick and graceful termination!</p>
<p>We can demonstrate this by building up from an application which, initially, does not use
either: </p>
<div class="code"><div class="highlight"><pre><span></span>    <span class="kn">package</span> <span class="nx">main</span><br />&nbsp;<br />    <span class="kn">import</span> <span class="p">(</span><br />            <span class="s">&quot;fmt&quot;</span><br />            <span class="s">&quot;log&quot;</span><br />            <span class="s">&quot;math/rand&quot;</span><br />            <span class="s">&quot;os&quot;</span><br />            <span class="s">&quot;os/signal&quot;</span><br />            <span class="s">&quot;syscall&quot;</span><br />            <span class="s">&quot;time&quot;</span><br />    <span class="p">)</span><br />&nbsp;<br />    <span class="kd">func</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span><br />            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Received job %d\n&quot;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span><br />    <span class="p">}</span><br />&nbsp;<br />    <span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span><br />            <span class="nx">rand</span><span class="p">.</span><span class="nx">Seed</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">Unix</span><span class="p">())</span><br />    <span class="p">}</span><br />&nbsp;<br />    <span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span><br />            <span class="kd">var</span> <span class="p">(</span><br />                    <span class="nx">closing</span>   <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span><br />                    <span class="nx">ticker</span>    <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">NewTicker</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span><br />                    <span class="nx">logger</span>    <span class="p">=</span> <span class="nx">log</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">log</span><span class="p">.</span><span class="nx">LstdFlags</span><span class="p">)</span><br />                    <span class="nx">batchSize</span> <span class="p">=</span> <span class="mi">6</span><br />                    <span class="nx">jobs</span>      <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">batchSize</span><span class="p">)</span><br />            <span class="p">)</span><br />&nbsp;<br />            <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span><br />                    <span class="nx">signals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><br />                    <span class="nx">signal</span><span class="p">.</span><span class="nx">Notify</span><span class="p">(</span><span class="nx">signals</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGTERM</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Interrupt</span><span class="p">)</span><br />                    <span class="o">&lt;-</span><span class="nx">signals</span><br />                    <span class="nb">close</span><span class="p">(</span><span class="nx">closing</span><span class="p">)</span><br />            <span class="p">}()</span><br />    <span class="nx">loop</span><span class="p">:</span><br />            <span class="k">for</span> <span class="p">{</span><br />                    <span class="k">select</span> <span class="p">{</span><br />                    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">closing</span><span class="p">:</span><br />                            <span class="k">break</span> <span class="nx">loop</span><br />                    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span><br />                            <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">batchSize</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span><br />                                    <span class="nx">jobs</span> <span class="o">&lt;-</span> <span class="nx">n</span><br />                                    <span class="k">go</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">jobs</span><span class="p">)</span><br />                            <span class="p">}</span><br />                            <span class="nx">logger</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Completed doing %d things.&quot;</span><span class="p">,</span> <span class="nx">batchSize</span><span class="p">)</span><br />                    <span class="p">}</span><br />            <span class="p">}</span><br />    <span class="p">}</span><br /></pre></div><br /></div>

<p>When the program is run, we observe the sequence of <em>"Received job ..."</em> messages alongside the completion message (<em>"Completed doing .."</em>). It might look something like this:</p>
<pre><code>Received job 0
Received job 1
Received job 2
2021/02/08 21:30:59 Completed doing 6 things.
Received job 3
Received job 4
Received job 5
2021/02/08 21:31:00 Completed doing 6 things.
</code></pre>
<p>The results don't print consistently! This makes sense as we know that goroutines are not
blocking so unless we do somethign about it, code after them will execute immediately. We can add a
<code>WaitGroup</code> to improve flow. First, define it in the <code>var</code> block:</p>
<div class="code"><div class="highlight"><pre><span></span>    <span class="kd">var</span> <span class="p">(</span><br />        <span class="p">..</span><br />        <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><br />    <span class="p">)</span><br />    <br /></pre></div><br /></div>

<p>Adjust the loop:</p>
<div class="code"><div class="highlight"><pre><span></span>    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">batchSize</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span><br />        <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><br />        <span class="nx">jobs</span> <span class="o">&lt;-</span> <span class="nx">n</span><br />        <span class="k">go</span> <span class="nx">doSomething</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">,</span> <span class="nx">jobs</span><span class="p">)</span><br />    <span class="p">}</span><br />    <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span><br />    <span class="nx">logger</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Completed doing %d things.&quot;</span><span class="p">,</span> <span class="nx">batchSize</span><span class="p">)</span><br />    <br /></pre></div><br /></div>

<p>And finally, the goroutine:</p>
<div class="code"><div class="highlight"><pre><span></span>    <span class="kd">func</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">,</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span><br />        <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span><br />        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Received job %d\n&quot;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span><br />    <span class="p">}</span><br />    <br /></pre></div><br /></div>

<p><a href="https://golang.org/pkg/sync/#WaitGroup">WaitGroups</a> wait for a collection of
goroutines to finish. If we read the code out loud, we can see that:</p>
<ol>
<li>On each iteration of the loop, we add <code>1</code> to the WaitGroup. We add <code>1</code>
   because our goroutine will call <code>wg.Done()</code> once, which decrements the
   WaitGroup counter by one. It balances out as each goroutine returns.</li>
<li>Before the <code>logger</code> call, we add <code>wg.Wait()</code>. This tells our Go program to block
   until the WaitGroup counter is zero. The counter will be zero when all
   goroutines have called <code>wg.Done()</code></li>
</ol>
<p>Simple, right? If we run the program again we can see the results print more
consistently:</p>
<pre><code>2021/02/08 21:46:47 Completed doing 6 things.
Received job 0
Received job 1
Received job 2
Received job 4
Received job 5
Received job 3
2021/02/08 21:46:48 Completed doing 6 things.
Received job 0
Received job 2
Received job 3
Received job 4
Received job 5
Received job 1
</code></pre>
<p>By the way, it's expected the jobs won't be ordered! We haven't done anything to
ensure that.</p>
<p>Before we continue, run the application as it is thus far and try to terminate it,
usually this is done by hitting <code>Control-d</code>. The program should exit without issue.</p>
<p>To demonstrate further need for control, let's add a piece of code that's more akin to a real-world
scenario. We'll make a new function which calls out to an API and expects a response.
We'll then use <code>context.WithCancel</code> to cancel the request while it's in flight.</p>
<p>First, create the new function without any context. It's going to be heavier,
so follow the in-line commentary as necessary:</p>
<div class="code"><div class="highlight"><pre><span></span>    <span class="kd">func</span> <span class="nx">doAPICall</span><span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span><br />            <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span><br />&nbsp;<br />            <span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">NewRequest</span><span class="p">(</span><span class="s">&quot;GET&quot;</span><span class="p">,</span> <span class="s">&quot;https://httpstat.us/200&quot;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span><br />            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><br />                    <span class="k">return</span> <span class="nx">err</span><br />            <span class="p">}</span><br />&nbsp;<br />            <span class="c1">// The httpstat.us API accepts a sleep parameter which sleeps the request for the</span><br />            <span class="c1">// passed time in ms</span><br />            <span class="nx">q</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Query</span><span class="p">()</span><br />            <span class="nx">sleepMin</span> <span class="o">:=</span> <span class="mi">1000</span><br />            <span class="nx">sleepMax</span> <span class="o">:=</span> <span class="mi">4000</span><br />            <span class="nx">q</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="s">&quot;sleep&quot;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">Intn</span><span class="p">(</span><span class="nx">sleepMax</span><span class="o">-</span><span class="nx">sleepMin</span><span class="p">)</span><span class="o">+</span><span class="nx">sleepMin</span><span class="p">))</span><br />            <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">RawQuery</span> <span class="p">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Encode</span><span class="p">()</span><br />&nbsp;<br />            <span class="c1">// Make the request to the API in an anonymous function, using a channel to</span><br />            <span class="c1">// communicate the results</span><br />            <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><br />            <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span><br />                    <span class="c1">// For the purposes of this example, we&#39;re not doing anything with the response.</span><br />                    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">DefaultClient</span><span class="p">.</span><span class="nx">Do</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span><br />                    <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">err</span><br />            <span class="p">}()</span><br />&nbsp;<br />            <span class="c1">// Block until the channel is populated</span><br />            <span class="k">return</span> <span class="o">&lt;-</span><span class="nx">c</span><br />    <span class="p">}</span><br />    <br /></pre></div><br /></div>

<p>Modify the ticker interval; remove the previous call to <code>doSomething</code>, optionally drop the
<code>jobs</code> channel (we won't use it further), and add a call to <code>doAPICall</code>:</p>
<div class="code"><div class="highlight"><pre><span></span>    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">batchSize</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span><br />        <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><br />        <span class="k">go</span> <span class="nx">doAPICall</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span><br />    <span class="p">}</span><br />    <br /></pre></div><br /></div>

<p>Run the application and try to exit again.</p>
<ul>
<li>The WaitGroup continues to wait until all go routines are finished. </li>
<li>The <code>doAPICall</code> function blocks until a response is returned from the <code>httpstat.us</code> API, and that can
  range anywhere from <code>1000</code> to <code>4000</code> ms.</li>
<li>Depending on when you try to terminate the application, it can be difficult to do so (you may
  not notice this on first pass, run it a few times and try to terminate at different
  times)</li>
</ul>
<p>Now to demonstrate how <code>context.WithCancel</code> provides further control over program cancellation. When <code>context.WithCancel</code> is initialised, it provides a context and a <code>CancelFunc</code>. This cancel func can cancel the context, which sounds confusing at first pass; Reading <a href="https://blog.golang.org/context">Go Concurrency Patterns: Context</a> from The Go Blog helped, and I recommend checking that out after this post!</p>
<p>Ok, back to it. There's little that needs to be done to the application to have it support this
cancellation flow. First, create a new context with cancellation function:</p>
<div class="code"><div class="highlight"><pre><span></span>    <span class="kd">var</span> <span class="p">(</span><br />        <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">())</span><br />        <span class="o">...</span><br />    <span class="p">)</span><br />    <br /></pre></div><br /></div>

<p>Then, in the anonymous function where we watch for program termination, call the <code>CancelFunc</code> after
the <code>signals</code> channel is notified. This means that the context will be considered cancelled:</p>
<div class="code"><div class="highlight"><pre><span></span>    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span><br />            <span class="nx">signals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><br />            <span class="nx">signal</span><span class="p">.</span><span class="nx">Notify</span><span class="p">(</span><span class="nx">signals</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGTERM</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Interrupt</span><span class="p">)</span><br />            <span class="o">&lt;-</span><span class="nx">signals</span><br />            <span class="nx">logger</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Initiating shutdown of producer.&quot;</span><span class="p">)</span><br />            <span class="nx">cancel</span><span class="p">()</span><br />            <span class="nb">close</span><span class="p">(</span><span class="nx">closing</span><span class="p">)</span><br />    <span class="p">}()</span><br />    <br /></pre></div><br /></div>

<p>Then, adjust the <code>doAPICall</code> function to accept a context, and modify the return statement
to use a blocking <code>select</code>, waiting on either the <code>ctx.Done</code> channel or the request
response. Parts of the function snipped for brevity:</p>
<div class="code"><div class="highlight"><pre><span></span>    <span class="kd">func</span> <span class="nx">doAPICall</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="o">...</span><span class="p">.)</span> <span class="p">{</span><br />        <span class="c1">// Cancel the request if ctx.Done is closed or await the response</span><br />        <span class="k">select</span> <span class="p">{</span><br />        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">Done</span><span class="p">():</span><br />            <span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Err</span><span class="p">()</span><br />        <span class="k">case</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span><br />            <span class="k">return</span> <span class="nx">err</span><br />        <span class="p">}</span><br />    <span class="p">}</span><br />    <br /></pre></div><br /></div>

<p>Finally, ensure the call to <code>doAPICall</code> has been adjusted to pass the context. Now, run
the application and terminate it at different start times.</p>
<p>What happens now? The application terminates immediately. The blocking <code>select</code> call
watches for the closure of <code>ctx.Done</code> or the response on <code>c</code>, whichever comes first. When
the application is terminated, <code>ctx.Done</code> takes precedence and the function returns early,
not concerning itself with the response of the request. The WaitGroup continues to do its
specific job and the flow of the application during termination is much improved!</p>
<p>There's many ways this can be expanded or used, so please consider it a starting point. I
initially struggled understanding how I could use <code>WaitGroup</code> and <code>context.WithCancel</code> in
combination, so I hope this was useful!</p>
<p>For reference, here's the code in its entirety:</p>
<div class="code"><div class="highlight"><pre><span></span>    <span class="kn">package</span> <span class="nx">main</span><br />&nbsp;<br />    <span class="kn">import</span> <span class="p">(</span><br />            <span class="s">&quot;context&quot;</span><br />            <span class="s">&quot;fmt&quot;</span><br />            <span class="s">&quot;log&quot;</span><br />            <span class="s">&quot;math/rand&quot;</span><br />            <span class="s">&quot;net/http&quot;</span><br />            <span class="s">&quot;os&quot;</span><br />            <span class="s">&quot;os/signal&quot;</span><br />            <span class="s">&quot;sync&quot;</span><br />            <span class="s">&quot;syscall&quot;</span><br />            <span class="s">&quot;time&quot;</span><br />    <span class="p">)</span><br />&nbsp;<br />    <span class="kd">func</span> <span class="nx">doAPICall</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span><br />            <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span><br />&nbsp;<br />            <span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">NewRequest</span><span class="p">(</span><span class="s">&quot;GET&quot;</span><span class="p">,</span> <span class="s">&quot;https://httpstat.us/200&quot;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span><br />            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><br />                    <span class="k">return</span> <span class="nx">err</span><br />            <span class="p">}</span><br />&nbsp;<br />            <span class="c1">// The httpstat.us API accepts a sleep parameter which sleeps the request for the</span><br />            <span class="c1">// passed time in ms</span><br />            <span class="nx">q</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Query</span><span class="p">()</span><br />            <span class="nx">sleepMin</span> <span class="o">:=</span> <span class="mi">1000</span><br />            <span class="nx">sleepMax</span> <span class="o">:=</span> <span class="mi">4000</span><br />            <span class="nx">q</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="s">&quot;sleep&quot;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">Intn</span><span class="p">(</span><span class="nx">sleepMax</span><span class="o">-</span><span class="nx">sleepMin</span><span class="p">)</span><span class="o">+</span><span class="nx">sleepMin</span><span class="p">))</span><br />            <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">RawQuery</span> <span class="p">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Encode</span><span class="p">()</span><br />&nbsp;<br />            <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><br />            <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span><br />                    <span class="c1">// For the purposes of this example, we&#39;re not doing anything with the response.</span><br />                    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">DefaultClient</span><span class="p">.</span><span class="nx">Do</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span><br />                    <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">err</span><br />            <span class="p">}()</span><br />&nbsp;<br />            <span class="c1">// Block until either channel is populated or closed</span><br />            <span class="k">select</span> <span class="p">{</span><br />            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">Done</span><span class="p">():</span><br />                    <span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Err</span><span class="p">()</span><br />            <span class="k">case</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span><br />                    <span class="k">return</span> <span class="nx">err</span><br />            <span class="p">}</span><br />    <span class="p">}</span><br />&nbsp;<br />    <span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span><br />            <span class="nx">rand</span><span class="p">.</span><span class="nx">Seed</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">Unix</span><span class="p">())</span><br />    <span class="p">}</span><br />&nbsp;<br />    <span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span><br />            <span class="kd">var</span> <span class="p">(</span><br />                    <span class="nx">closing</span>     <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span><br />                    <span class="nx">ticker</span>      <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">NewTicker</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span><br />                    <span class="nx">logger</span>      <span class="p">=</span> <span class="nx">log</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">log</span><span class="p">.</span><span class="nx">LstdFlags</span><span class="p">)</span><br />                    <span class="nx">batchSize</span>   <span class="p">=</span> <span class="mi">6</span><br />                    <span class="nx">wg</span>          <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><br />                    <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">())</span><br />            <span class="p">)</span><br />&nbsp;<br />            <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span><br />                    <span class="nx">signals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><br />                    <span class="nx">signal</span><span class="p">.</span><span class="nx">Notify</span><span class="p">(</span><span class="nx">signals</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGTERM</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Interrupt</span><span class="p">)</span><br />                    <span class="o">&lt;-</span><span class="nx">signals</span><br />                    <span class="nx">cancel</span><span class="p">()</span><br />                    <span class="nb">close</span><span class="p">(</span><span class="nx">closing</span><span class="p">)</span><br />            <span class="p">}()</span><br />    <span class="nx">loop</span><span class="p">:</span><br />            <span class="k">for</span> <span class="p">{</span><br />                    <span class="k">select</span> <span class="p">{</span><br />                    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">closing</span><span class="p">:</span><br />                            <span class="k">break</span> <span class="nx">loop</span><br />                    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span><br />                            <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">batchSize</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span><br />                                    <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><br />                                    <span class="k">go</span> <span class="nx">doAPICall</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span><br />                            <span class="p">}</span><br />                            <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span><br />                            <span class="nx">logger</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Completed doing %d things.&quot;</span><span class="p">,</span> <span class="nx">batchSize</span><span class="p">)</span><br />                    <span class="p">}</span><br />            <span class="p">}</span><br />    <span class="p">}</span><br />    <br /></pre></div><br /></div>

<p>As a final note, a portion of this code was inspired by the <a href="https://blog.golang.org/context">Go Concurrency Patterns:
Context</a> blog post, which I, again, recommend. It
introduces further controls like <code>context.WithTimeout</code> and well, the Go blog is a treasure that everyone should read!</p>
</article>

    </main>
</body>
</html>
